/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.12
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

module tinyspline;

static import tinyspline_im;
static import core.stdc.config;

static import std.conv;
static import std.string;

static import std.conv;
static import std.string;

static import std.algorithm;
static import std.exception;
static import std.range;
static import std.traits;


int TS_MAX_NUM_KNOTS() @property {
  auto ret = tinyspline_im.TS_MAX_NUM_KNOTS_get();
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

double TS_MIN_KNOT_VALUE() @property {
  auto ret = tinyspline_im.TS_MIN_KNOT_VALUE_get();
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

double TS_MAX_KNOT_VALUE() @property {
  auto ret = tinyspline_im.TS_MAX_KNOT_VALUE_get();
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

double TS_KNOT_EPSILON() @property {
  auto ret = tinyspline_im.TS_KNOT_EPSILON_get();
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

enum BSplineType {
  OPENED = 0,
  CLAMPED = 1,
  BEZIERS = 2
}

size_t ts_bspline_degree(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_degree(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_degree(SWIGTYPE_p_tsBSpline spline, size_t deg, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_degree(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), deg, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_order(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_order(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_order(SWIGTYPE_p_tsBSpline spline, size_t order, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_order(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), order, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_dimension(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_dimension(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_dimension(SWIGTYPE_p_tsBSpline spline, size_t dim, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_dimension(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), dim, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_len_control_points(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_len_control_points(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_num_control_points(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_num_control_points(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_sof_control_points(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_sof_control_points(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_control_points(SWIGTYPE_p_tsBSpline spline, double** ctrlp, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_control_points(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)ctrlp, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_control_point_at(SWIGTYPE_p_tsBSpline spline, size_t index, double** ctrlp, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_control_point_at(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), index, cast(void*)ctrlp, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_control_points(SWIGTYPE_p_tsBSpline spline, double* ctrlp, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_control_points(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)ctrlp, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_control_point_at(SWIGTYPE_p_tsBSpline spline, size_t index, double* ctrlp, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_control_point_at(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), index, cast(void*)ctrlp, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_num_knots(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_num_knots(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_bspline_sof_knots(SWIGTYPE_p_tsBSpline spline) {
  auto ret = tinyspline_im.ts_bspline_sof_knots(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_knots(SWIGTYPE_p_tsBSpline spline, double** knots, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_knots(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)knots, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_set_knots(SWIGTYPE_p_tsBSpline spline, double* knots, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_set_knots(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)knots, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

double ts_deboornet_knot(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_knot(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_index(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_index(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_multiplicity(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_multiplicity(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_num_insertions(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_num_insertions(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_dimension(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_dimension(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_len_points(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_len_points(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_num_points(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_num_points(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_sof_points(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_sof_points(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_deboornet_points(SWIGTYPE_p_tsDeBoorNet net, double** points, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_deboornet_points(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net), cast(void*)points, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_len_result(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_len_result(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_num_result(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_num_result(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

size_t ts_deboornet_sof_result(SWIGTYPE_p_tsDeBoorNet net) {
  auto ret = tinyspline_im.ts_deboornet_sof_result(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_deboornet_result(SWIGTYPE_p_tsDeBoorNet net, double** result, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_deboornet_result(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net), cast(void*)result, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

SWIGTYPE_p_tsBSpline ts_bspline_init() {
  SWIGTYPE_p_tsBSpline ret = new SWIGTYPE_p_tsBSpline(tinyspline_im.ts_bspline_init(), true);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_new(size_t num_control_points, size_t dimension, size_t degree, BSplineType type, SWIGTYPE_p_tsBSpline spline, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_new(num_control_points, dimension, degree, cast(int)type, SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_copy(SWIGTYPE_p_tsBSpline src, SWIGTYPE_p_tsBSpline dest, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_copy(SWIGTYPE_p_tsBSpline.swigGetCPtr(src), SWIGTYPE_p_tsBSpline.swigGetCPtr(dest), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

void ts_bspline_move(SWIGTYPE_p_tsBSpline src, SWIGTYPE_p_tsBSpline dest) {
  tinyspline_im.ts_bspline_move(SWIGTYPE_p_tsBSpline.swigGetCPtr(src), SWIGTYPE_p_tsBSpline.swigGetCPtr(dest));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

void ts_bspline_free(SWIGTYPE_p_tsBSpline spline) {
  tinyspline_im.ts_bspline_free(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

SWIGTYPE_p_tsDeBoorNet ts_deboornet_init() {
  SWIGTYPE_p_tsDeBoorNet ret = new SWIGTYPE_p_tsDeBoorNet(tinyspline_im.ts_deboornet_init(), true);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_deboornet_copy(SWIGTYPE_p_tsDeBoorNet src, SWIGTYPE_p_tsDeBoorNet dest, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_deboornet_copy(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(src), SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(dest), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

void ts_deboornet_move(SWIGTYPE_p_tsDeBoorNet src, SWIGTYPE_p_tsDeBoorNet dest) {
  tinyspline_im.ts_deboornet_move(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(src), SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(dest));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

void ts_deboornet_free(SWIGTYPE_p_tsDeBoorNet net) {
  tinyspline_im.ts_deboornet_free(SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(net));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

int ts_bspline_interpolate_cubic(double* points, size_t n, size_t dim, SWIGTYPE_p_tsBSpline _spline_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_interpolate_cubic(cast(void*)points, n, dim, SWIGTYPE_p_tsBSpline.swigGetCPtr(_spline_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_eval(SWIGTYPE_p_tsBSpline spline, double u, SWIGTYPE_p_tsDeBoorNet _deBoorNet_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_eval(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), u, SWIGTYPE_p_tsDeBoorNet.swigGetCPtr(_deBoorNet_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

void ts_bspline_domain(SWIGTYPE_p_tsBSpline spline, double* min, double* max) {
  tinyspline_im.ts_bspline_domain(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)min, cast(void*)max);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

int ts_bspline_is_closed(SWIGTYPE_p_tsBSpline spline, double epsilon, int* closed, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_is_closed(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), epsilon, cast(void*)closed, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_derive(SWIGTYPE_p_tsBSpline spline, size_t n, SWIGTYPE_p_tsBSpline _derivative_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_derive(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), n, SWIGTYPE_p_tsBSpline.swigGetCPtr(_derivative_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_insert_knot(SWIGTYPE_p_tsBSpline spline, double u, size_t n, SWIGTYPE_p_tsBSpline _result_, size_t* _k_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_insert_knot(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), u, n, SWIGTYPE_p_tsBSpline.swigGetCPtr(_result_), cast(void*)_k_, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_split(SWIGTYPE_p_tsBSpline spline, double u, SWIGTYPE_p_tsBSpline _split_, size_t* _k_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_split(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), u, SWIGTYPE_p_tsBSpline.swigGetCPtr(_split_), cast(void*)_k_, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_buckle(SWIGTYPE_p_tsBSpline spline, double b, SWIGTYPE_p_tsBSpline _buckled_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_buckle(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), b, SWIGTYPE_p_tsBSpline.swigGetCPtr(_buckled_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_to_beziers(SWIGTYPE_p_tsBSpline spline, SWIGTYPE_p_tsBSpline _beziers_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_to_beziers(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), SWIGTYPE_p_tsBSpline.swigGetCPtr(_beziers_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_to_json(SWIGTYPE_p_tsBSpline spline, char** _json_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_to_json(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), cast(void*)_json_, SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_from_json(string json, SWIGTYPE_p_tsBSpline _spline_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_from_json((json ? std.string.toStringz(json) : null), SWIGTYPE_p_tsBSpline.swigGetCPtr(_spline_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_save_json(SWIGTYPE_p_tsBSpline spline, string path, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_save_json(SWIGTYPE_p_tsBSpline.swigGetCPtr(spline), (path ? std.string.toStringz(path) : null), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_bspline_load_json(string path, SWIGTYPE_p_tsBSpline _spline_, SWIGTYPE_p_tsStatus status) {
  int ret = cast(int)tinyspline_im.ts_bspline_load_json((path ? std.string.toStringz(path) : null), SWIGTYPE_p_tsBSpline.swigGetCPtr(_spline_), SWIGTYPE_p_tsStatus.swigGetCPtr(status));
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

int ts_fequals(double x, double y) {
  auto ret = tinyspline_im.ts_fequals(x, y);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

void ts_arr_fill(double* arr, size_t num, double val) {
  tinyspline_im.ts_arr_fill(cast(void*)arr, num, val);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
}

double ts_ctrlp_dist2(double* x, double* y, size_t dim) {
  auto ret = tinyspline_im.ts_ctrlp_dist2(cast(void*)x, cast(void*)y, dim);
  if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  return ret;
}

class DeBoorNet {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          tinyspline_im.delete_DeBoorNet(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this(DeBoorNet other) {
    this(tinyspline_im.new_DeBoorNet(DeBoorNet.swigGetCPtr(other)), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public double knot() const {
    auto ret = tinyspline_im.DeBoorNet_knot(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t index() const {
    auto ret = tinyspline_im.DeBoorNet_index(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t multiplicity() const {
    auto ret = tinyspline_im.DeBoorNet_multiplicity(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t numInsertions() const {
    auto ret = tinyspline_im.DeBoorNet_numInsertions(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t dimension() const {
    auto ret = tinyspline_im.DeBoorNet_dimension(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector points() const {
    Vector ret = new Vector(tinyspline_im.DeBoorNet_points(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector result() const {
    Vector ret = new Vector(tinyspline_im.DeBoorNet_result(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }
}

class Domain {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          tinyspline_im.delete_Domain(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this(double min, double max) {
    this(tinyspline_im.new_Domain__SWIG_0(min, max), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(Domain other) {
    this(tinyspline_im.new_Domain__SWIG_1(Domain.swigGetCPtr(other)), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public double min() const {
    auto ret = tinyspline_im.Domain_min(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public double max() const {
    auto ret = tinyspline_im.Domain_max(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }
}

class BSpline {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          tinyspline_im.delete_BSpline(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this() {
    this(tinyspline_im.new_BSpline__SWIG_0(), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(BSpline other) {
    this(tinyspline_im.new_BSpline__SWIG_1(BSpline.swigGetCPtr(other)), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(size_t nCtrlp, size_t dim, size_t deg, BSplineType type) {
    this(tinyspline_im.new_BSpline__SWIG_2(nCtrlp, dim, deg, cast(int)type), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(size_t nCtrlp, size_t dim, size_t deg) {
    this(tinyspline_im.new_BSpline__SWIG_3(nCtrlp, dim, deg), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(size_t nCtrlp, size_t dim) {
    this(tinyspline_im.new_BSpline__SWIG_4(nCtrlp, dim), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(size_t nCtrlp) {
    this(tinyspline_im.new_BSpline__SWIG_5(nCtrlp), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public DeBoorNet opCall(double u) const {
    DeBoorNet ret = new DeBoorNet(tinyspline_im.BSpline_opCall(cast(void*)swigCPtr, u), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t degree() const {
    auto ret = tinyspline_im.BSpline_degree(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t order() const {
    auto ret = tinyspline_im.BSpline_order(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t dimension() const {
    auto ret = tinyspline_im.BSpline_dimension(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector controlPoints() const {
    Vector ret = new Vector(tinyspline_im.BSpline_controlPoints(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector controlPointAt(size_t index) const {
    void* cPtr = tinyspline_im.BSpline_controlPointAt(cast(void*)swigCPtr, index);
    Vector ret = (cPtr is null) ? null : new Vector(cPtr, false);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector knots() const {
    Vector ret = new Vector(tinyspline_im.BSpline_knots(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public DeBoorNet eval(double u) const {
    DeBoorNet ret = new DeBoorNet(tinyspline_im.BSpline_eval(cast(void*)swigCPtr, u), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public Domain domain() const {
    Domain ret = new Domain(tinyspline_im.BSpline_domain(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool isClosed(double epsilon) const {
    bool ret = tinyspline_im.BSpline_isClosed__SWIG_0(cast(void*)swigCPtr, epsilon) ? true : false;
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool isClosed() const {
    bool ret = tinyspline_im.BSpline_isClosed__SWIG_1(cast(void*)swigCPtr) ? true : false;
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toJSON() {
    string ret = std.conv.to!string(tinyspline_im.BSpline_toJSON(cast(void*)swigCPtr));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public void fromJSON(string json) {
    tinyspline_im.BSpline_fromJSON(cast(void*)swigCPtr, (json ? std.string.toStringz(json) : null));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void save(string path) {
    tinyspline_im.BSpline_save(cast(void*)swigCPtr, (path ? std.string.toStringz(path) : null));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void load(string path) {
    tinyspline_im.BSpline_load(cast(void*)swigCPtr, (path ? std.string.toStringz(path) : null));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void setControlPoints(Vector ctrlp) {
    tinyspline_im.BSpline_setControlPoints(cast(void*)swigCPtr, Vector.swigGetCPtr(ctrlp));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void setControlPointAt(size_t index, Vector ctrlp) {
    tinyspline_im.BSpline_setControlPointAt(cast(void*)swigCPtr, index, Vector.swigGetCPtr(ctrlp));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void setKnots(Vector knots) {
    tinyspline_im.BSpline_setKnots(cast(void*)swigCPtr, Vector.swigGetCPtr(knots));
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public BSpline insertKnot(double u, size_t n) const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_insertKnot(cast(void*)swigCPtr, u, n), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public BSpline split(double u) const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_split(cast(void*)swigCPtr, u), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public BSpline buckle(double b) const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_buckle(cast(void*)swigCPtr, b), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public BSpline toBeziers() const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_toBeziers(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public BSpline derive(size_t n) const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_derive__SWIG_0(cast(void*)swigCPtr, n), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public BSpline derive() const {
    BSpline ret = new BSpline(tinyspline_im.BSpline_derive__SWIG_1(cast(void*)swigCPtr), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }
}

class Utils {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          tinyspline_im.delete_Utils(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public static BSpline interpolateCubic(Vector points, size_t dim) {
    BSpline ret = new BSpline(tinyspline_im.Utils_interpolateCubic(Vector.swigGetCPtr(points), dim), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public static bool fequals(double x, double y) {
    bool ret = tinyspline_im.Utils_fequals(x, y) ? true : false;
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }
}

class Vector {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          tinyspline_im.delete_Vector(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  alias size_t KeyType;
  alias double ValueType;

  this(ValueType[] values...) {
    this();
    reserve(values.length);
    foreach (e; values) {
      this ~= e;
    }
  }

  struct Range {
    private Vector _outer;
    private size_t _a, _b;

    this(Vector data, size_t a, size_t b) {
      _outer = data;
      _a = a;
      _b = b;
    }

    @property bool empty() const {
      assert((cast(Vector)_outer).length >= _b);
      return _a >= _b;
    }

    @property Range save() {
      return this;
    }

    @property ValueType front() {
      std.exception.enforce(!empty);
      return _outer[_a];
    }

    @property void front(ValueType value) {
      std.exception.enforce(!empty);
      _outer[_a] = std.algorithm.move(value);
    }

    void popFront() {
      std.exception.enforce(!empty);
      ++_a;
    }

    void opIndexAssign(ValueType value, size_t i) {
      i += _a;
      std.exception.enforce(i < _b && _b <= _outer.length);
      _outer[i] = value;
    }

    void opIndexOpAssign(string op)(ValueType value, size_t i) {
      std.exception.enforce(_outer && _a + i < _b && _b <= _outer.length);
      auto element = _outer[i];
      mixin("element "~op~"= value;");
      _outer[i] = element;
    }
  }

  // TODO: dup?

  Range opSlice() {
    return Range(this, 0, length);
  }

  Range opSlice(size_t a, size_t b) {
    std.exception.enforce(a <= b && b <= length);
    return Range(this, a, b);
  }

  size_t opDollar() const {
    return length;
  }

  @property ValueType front() {
    std.exception.enforce(!empty);
    return getElement(0);
  }

  @property void front(ValueType value) {
    std.exception.enforce(!empty);
    setElement(0, value);
  }

  @property ValueType back() {
    std.exception.enforce(!empty);
    return getElement(length - 1);
  }

  @property void back(ValueType value) {
    std.exception.enforce(!empty);
    setElement(length - 1, value);
  }

  ValueType opIndex(size_t i) {
    return getElement(i);
  }

  void opIndexAssign(ValueType value, size_t i) {
    setElement(i, value);
  }

  void opIndexOpAssign(string op)(ValueType value, size_t i) {
    auto element = this[i];
    mixin("element "~op~"= value;");
    this[i] = element;
  }

  ValueType[] opBinary(string op, Stuff)(Stuff stuff) if (op == "~") {
    ValueType[] result;
    result ~= this[];
    assert(result.length == length);
    result ~= stuff[];
    return result;
  }

  void opOpAssign(string op, Stuff)(Stuff stuff) if (op == "~") {
    static if (is(typeof(insertBack(stuff)))) {
      insertBack(stuff);
    } else if (is(typeof(insertBack(stuff[])))) {
      insertBack(stuff[]);
    } else {
      static assert(false, "Cannot append " ~ Stuff.stringof ~ " to " ~ typeof(this).stringof);
    }
  }

  alias size length;

  alias remove removeAny;
  alias removeAny stableRemoveAny;

  size_t insertBack(Stuff)(Stuff stuff)
  if (std.traits.isImplicitlyConvertible!(Stuff, ValueType)){
    push_back(stuff);
    return 1;
  }
  size_t insertBack(Stuff)(Stuff stuff)
  if (std.range.isInputRange!Stuff &&
      std.traits.isImplicitlyConvertible!(std.range.ElementType!Stuff, ValueType)) {
    size_t itemCount;
    foreach(item; stuff) {
      insertBack(item);
      ++itemCount;
    }
    return itemCount;
  }
  alias insertBack insert;

  alias pop_back removeBack;
  alias pop_back stableRemoveBack;

  size_t insertBefore(Stuff)(Range r, Stuff stuff)
  if (std.traits.isImplicitlyConvertible!(Stuff, ValueType)) {
    std.exception.enforce(r._outer.swigCPtr == swigCPtr && r._a < length);
    insertAt(r._a, stuff);
    return 1;
  }

  size_t insertBefore(Stuff)(Range r, Stuff stuff)
  if (std.range.isInputRange!Stuff && std.traits.isImplicitlyConvertible!(ElementType!Stuff, ValueType)) {
    std.exception.enforce(r._outer.swigCPtr == swigCPtr && r._a <= length);

    size_t insertCount;
    foreach(i, item; stuff) {
      insertAt(r._a + i, item);
      ++insertCount;
    }

    return insertCount;
  }

  size_t insertAfter(Stuff)(Range r, Stuff stuff) {
    // TODO: optimize
    immutable offset = r._a + r.length;
    std.exception.enforce(offset <= length);
    auto result = insertBack(stuff);
    std.algorithm.bringToFront(this[offset .. length - result],
      this[length - result .. length]);
    return result;
  }

  size_t replace(Stuff)(Range r, Stuff stuff)
  if (std.range.isInputRange!Stuff &&
      std.traits.isImplicitlyConvertible!(ElementType!Stuff, ValueType)) {
    immutable offset = r._a;
    std.exception.enforce(offset <= length);
    size_t result;
    for (; !stuff.empty; stuff.popFront()) {
      if (r.empty) {
        // append the rest
        return result + insertBack(stuff);
      }
      r.front = stuff.front;
      r.popFront();
      ++result;
    }
    // Remove remaining stuff in r
    remove(r);
    return result;
  }

  size_t replace(Stuff)(Range r, Stuff stuff)
  if (std.traits.isImplicitlyConvertible!(Stuff, ValueType))
  {
      if (r.empty)
      {
          insertBefore(r, stuff);
      }
      else
      {
          r.front = stuff;
          r.popFront();
          remove(r);
      }
      return 1;
  }

  Range linearRemove(Range r) {
    std.exception.enforce(r._a <= r._b && r._b <= length);
    immutable tailLength = length - r._b;
    linearRemove(r._a, r._b);
    return this[length - tailLength .. length];
  }
  alias remove stableLinearRemove;

  int opApply(int delegate(ref double value) dg) {
    int result;

    size_t currentSize = size();
    for (size_t i = 0; i < currentSize; ++i) {
      auto value = getElement(i);
      result = dg(value);
      setElement(i, value);
    }
    return result;
  }

  int opApply(int delegate(ref size_t index, ref double value) dg) {
    int result;

    size_t currentSize = size();
    for (size_t i = 0; i < currentSize; ++i) {
      auto value = getElement(i);

      // Workaround for http://d.puremagic.com/issues/show_bug.cgi?id=2443.
      auto index = i;

      result = dg(index, value);
      setElement(i, value);
    }
    return result;
  }

  public bool empty() const {
    bool ret = tinyspline_im.Vector_empty(cast(void*)swigCPtr) ? true : false;
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public void clear() {
    tinyspline_im.Vector_clear(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void push_back(double x) {
    tinyspline_im.Vector_push_back(cast(void*)swigCPtr, x);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void pop_back() {
    tinyspline_im.Vector_pop_back(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public size_t size() const {
    auto ret = tinyspline_im.Vector_size(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public size_t capacity() const {
    auto ret = tinyspline_im.Vector_capacity(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public void reserve(size_t n) {
    tinyspline_im.Vector_reserve(cast(void*)swigCPtr, n);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this() {
    this(tinyspline_im.new_Vector__SWIG_0(), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(Vector other) {
    this(tinyspline_im.new_Vector__SWIG_1(Vector.swigGetCPtr(other)), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public this(size_t capacity) {
    this(tinyspline_im.new_Vector__SWIG_2(capacity), true);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public double remove() {
    auto ret = tinyspline_im.Vector_remove__SWIG_0(cast(void*)swigCPtr);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public double remove(size_t index) {
    auto ret = tinyspline_im.Vector_remove__SWIG_1(cast(void*)swigCPtr, index);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public void removeBack(size_t how_many) {
    tinyspline_im.Vector_removeBack(cast(void*)swigCPtr, how_many);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void linearRemove(size_t start_index, size_t end_index) {
    tinyspline_im.Vector_linearRemove(cast(void*)swigCPtr, start_index, end_index);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public void insertAt(size_t index, double x) {
    tinyspline_im.Vector_insertAt(cast(void*)swigCPtr, index, x);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }

  public double getElement(size_t index) {
    auto ret = tinyspline_im.Vector_getElement(cast(void*)swigCPtr, index);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
    return ret;
  }

  public void setElement(size_t index, double val) {
    tinyspline_im.Vector_setElement(cast(void*)swigCPtr, index, val);
    if (tinyspline_im.SwigPendingException.isPending) throw tinyspline_im.SwigPendingException.retrieve();
  }
}

class SWIGTYPE_p_tsBSpline {
  private void* swigCPtr;

  public this(void* cObject, bool futureUse) {
    swigCPtr = cObject;
  }

  protected this() {
    swigCPtr = null;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;
}

class SWIGTYPE_p_tsStatus {
  private void* swigCPtr;

  public this(void* cObject, bool futureUse) {
    swigCPtr = cObject;
  }

  protected this() {
    swigCPtr = null;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;
}

class SWIGTYPE_p_tsDeBoorNet {
  private void* swigCPtr;

  public this(void* cObject, bool futureUse) {
    swigCPtr = cObject;
  }

  protected this() {
    swigCPtr = null;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin tinyspline_im.SwigOperatorDefinitions;
}
